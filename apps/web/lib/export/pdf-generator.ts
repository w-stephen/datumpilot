/**
 * Server-side PDF Generator for FCF Exports
 *
 * Generates PDF documents containing FCF visualizations and metadata.
 */

import { jsPDF } from "jspdf";
import type { FcfJson, MaterialConditionSymbol, Characteristic } from "@/lib/fcf/schema";
import { generateFcfSvg } from "./svg-generator";

// Constants
const CHARACTERISTIC_LABELS: Record<Characteristic, string> = {
  position: "Position",
  flatness: "Flatness",
  straightness: "Straightness",
  circularity: "Circularity",
  cylindricity: "Cylindricity",
  perpendicularity: "Perpendicularity",
  parallelism: "Parallelism",
  angularity: "Angularity",
  profile: "Profile",
  runout: "Runout",
  totalRunout: "Total Runout",
  other: "Other",
};

const MATERIAL_CONDITION_LABELS: Record<MaterialConditionSymbol, string> = {
  MMC: "Maximum Material Condition",
  LMC: "Least Material Condition",
  RFS: "Regardless of Feature Size",
};

export interface PdfGeneratorOptions {
  includeMetadata?: boolean;
  pageSize?: "a4" | "letter";
  orientation?: "portrait" | "landscape";
}

/**
 * Generate PDF buffer for an FCF
 */
export async function generateFcfPdf(
  fcf: FcfJson,
  options: PdfGeneratorOptions = {}
): Promise<Buffer> {
  const {
    includeMetadata = true,
    pageSize = "a4",
    orientation = "portrait",
  } = options;

  // Create PDF document
  const doc = new jsPDF({
    orientation,
    unit: "mm",
    format: pageSize,
  });

  const pageWidth = doc.internal.pageSize.getWidth();
  const pageHeight = doc.internal.pageSize.getHeight();
  const margin = 20;
  let yPos = margin;

  // Header
  doc.setFontSize(18);
  doc.setFont("helvetica", "bold");
  doc.text("Feature Control Frame", margin, yPos);
  yPos += 10;

  // Subtitle
  doc.setFontSize(10);
  doc.setFont("helvetica", "normal");
  doc.setTextColor(100, 100, 100);
  doc.text(`Generated by DatumPilot • ${new Date().toLocaleDateString()}`, margin, yPos);
  yPos += 15;

  // FCF Name
  if (fcf.name) {
    doc.setFontSize(14);
    doc.setFont("helvetica", "bold");
    doc.setTextColor(0, 0, 0);
    doc.text(fcf.name, margin, yPos);
    yPos += 10;
  }

  // Generate SVG and embed as image
  const svgString = generateFcfSvg(fcf, { scale: 2, backgroundColor: "#1A2332" });

  // Create a simple rectangular representation in PDF
  // Note: Full SVG embedding requires additional libraries
  const boxWidth = Math.min(pageWidth - margin * 2, 150);
  const boxHeight = 25;

  // Draw FCF box representation
  doc.setDrawColor(51, 65, 85); // #334155
  doc.setFillColor(26, 35, 50); // #1A2332
  doc.roundedRect(margin, yPos, boxWidth, boxHeight, 2, 2, "FD");

  // Add text representation of FCF
  doc.setFontSize(12);
  doc.setFont("courier", "bold");
  doc.setTextColor(248, 250, 252); // #F8FAFC

  let fcfText = "";
  if (fcf.characteristic) {
    fcfText += `[${CHARACTERISTIC_LABELS[fcf.characteristic]}]`;
  }
  if (fcf.tolerance?.value !== undefined) {
    fcfText += ` ${fcf.tolerance.diameter ? "⌀" : ""}${fcf.tolerance.value.toFixed(3)}`;
    if (fcf.tolerance.materialCondition && fcf.tolerance.materialCondition !== "RFS") {
      fcfText += ` (${fcf.tolerance.materialCondition})`;
    }
  }
  if (fcf.datums && fcf.datums.length > 0) {
    fcfText += ` | ${fcf.datums.map((d) => {
      let txt = d.id;
      if (d.materialCondition && d.materialCondition !== "RFS") {
        txt += `(${d.materialCondition})`;
      }
      return txt;
    }).join(" ")}`;
  }

  doc.text(fcfText, margin + 5, yPos + boxHeight / 2 + 3);
  yPos += boxHeight + 15;

  // Metadata section
  if (includeMetadata) {
    doc.setTextColor(0, 0, 0);
    doc.setFontSize(12);
    doc.setFont("helvetica", "bold");
    doc.text("Specification Details", margin, yPos);
    yPos += 8;

    doc.setFontSize(10);
    doc.setFont("helvetica", "normal");

    const addRow = (label: string, value: string) => {
      doc.setFont("helvetica", "bold");
      doc.text(`${label}:`, margin, yPos);
      doc.setFont("helvetica", "normal");
      doc.text(value, margin + 50, yPos);
      yPos += 6;
    };

    // Characteristic
    if (fcf.characteristic) {
      addRow("Characteristic", CHARACTERISTIC_LABELS[fcf.characteristic]);
    }

    // Feature Type
    if (fcf.featureType) {
      addRow("Feature Type", fcf.featureType.charAt(0).toUpperCase() + fcf.featureType.slice(1));
    }

    // Tolerance
    if (fcf.tolerance?.value !== undefined) {
      let tolText = `${fcf.tolerance.value.toFixed(3)} ${fcf.sourceUnit || "mm"}`;
      if (fcf.tolerance.diameter) {
        tolText = `⌀${tolText}`;
      }
      addRow("Tolerance", tolText);

      if (fcf.tolerance.materialCondition) {
        addRow("Material Condition", MATERIAL_CONDITION_LABELS[fcf.tolerance.materialCondition]);
      }
    }

    // Datums
    if (fcf.datums && fcf.datums.length > 0) {
      yPos += 4;
      doc.setFont("helvetica", "bold");
      doc.text("Datum References:", margin, yPos);
      yPos += 6;

      fcf.datums.forEach((datum, index) => {
        let datumText = `${index + 1}. Datum ${datum.id}`;
        if (datum.materialCondition && datum.materialCondition !== "RFS") {
          datumText += ` (${MATERIAL_CONDITION_LABELS[datum.materialCondition]})`;
        }
        doc.setFont("helvetica", "normal");
        doc.text(datumText, margin + 10, yPos);
        yPos += 5;
      });
    }

    // Units
    if (fcf.sourceUnit) {
      yPos += 4;
      addRow("Units", fcf.sourceUnit.toUpperCase());
    }
  }

  // Footer
  doc.setFontSize(8);
  doc.setTextColor(150, 150, 150);
  doc.text(
    "DatumPilot • GD&T Feature Control Frame Builder",
    pageWidth / 2,
    pageHeight - 10,
    { align: "center" }
  );

  // Return as buffer
  const arrayBuffer = doc.output("arraybuffer");
  return Buffer.from(arrayBuffer);
}
